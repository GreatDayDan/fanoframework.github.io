---
title: Creating Hello World web application from scratch
description: Step by step tutorial for creating basic hello world web application from scratch
---

<h1 class="major">Creating Hello World web application from scratch</h1>

In this step by step tutorial, we are going to create a simple CGI web application
that display greeting message from scratch.

## Application Functionalities

- Page which display greeting message. If query string `name=[a value]` is set, for example `name=Jon`, we will display string 'Hello Jon' otherwise we display 'Hello everybody'.

## Project directory structure

For this project, we will create following directory structures

```
hello-world
--bin
----unit
--src
----App
------Hello
--------Controllers
----------Factories
--------Views
----------Factories
----Resources
------Templates
--------Hello
--tools
--public
----css
----js
--vendor
----fano
```

- `bin` directory will store any binary files generated by compiler. Our final executable application binary will be store here.
- `bin/unit` will store any compiled unit binaries generated by compiler.
- `src` directory will store our application source codes.
- `tools` directory will store helper shell scripts.
- `public` directory is our application document root which will contains any public assets accessible from client such CSS and JavaScript files.
- `vendor/fano` directory will contains Fano Framework source code.

## Creating git repository and add Fano Framework respository

After project directory structures setup, from shell terminal, change directory to `hello-world` directory and run

```
$ git init
$ git submodule add https://github.com/fanoframework/fano.git vendor/fano
```

This will initialize empty git repository and add Fano Framework to
`hello-world/vendor/fano` directory

## Creating main program

Create new file `hello-world/src/hello.pas` and put following code

```
program hello;

uses

    fano,
    helloapp;

var
    appInstance : IWebApplication;

begin
    appInstance := THelloApp.create();
    appInstance.run();
end.
```

This will be our main application which will be compiled into executable binary.

## Creating hello application unit

Create new file `hello-world/src/helloapp.pas` and put following code

```
unit helloapp;

interface

uses
    fano;

type

    THelloApp = class(TSimpleWebApplication)
    protected
        procedure buildDependencies(const container : IDependencyContainer); override;
        procedure buildRoutes(const container : IDependencyContainer); override;
        function initDispatcher(const container : IDependencyContainer) : IDispatcher; override;
    end;

implementation

uses

    sysutils;

    procedure THelloApp.buildDependencies(const container : IDependencyContainer);
    begin
        //TODO: implement build application dependencies
    end;

    procedure THelloApp.buildRoutes(const container : IDependencyContainer);
    begin
        //TODO: implement build application routes
    end;

    function THelloApp.initDispatcher(const container : IDependencyContainer) : IDispatcher;
    begin
        //TODO: implement build application dispatcher
    end;
end.
```

## Build application dependencies

In order to work, application needs some service to be registered into
dependency container. Add following code in `buildDependencies()` method

```
procedure THelloApp.buildDependencies(const container : IDependencyContainer);
begin
    container.factory(
        'routeMiddlewares',
        TNullMiddlewareCollectionAwareFactory.create()
    );
    container.add('viewParams', TViewParametersFactory.create());
end;
```

In code above, we register service name `routeMiddlewares` and its factory class
which responsible to create instance of `IMiddlewareCollectionAware` interface.
We will not use middleware yet, `TNullMiddlewareCollectionAwareFactory` creates null class which implements that interface but actually does nothing. See [Middlewares](/middlewares) for more information.

We also register `IViewParameters` instance which we will be used to pass data from controller to view. See [Displaying Data in View](/working-with-views/displaying-data-in-view) for more information.

## Build application routes

A route is basically an association rule between request and code that handles it.
Read [Working with router](/working-with-router) for more information.

Add code to `buildRoutes()` method to register a route.

```
procedure THelloApp.buildRoutes(const container : IDependencyContainer);
var router : IRouter;
begin
    router := container.get('router') as IRouter;
    try
        router.get('/', container.get('helloController') as IRouteHandler);
    finally
        router := nil;
    end;
end;
```

So when user made `GET` request to `http://[our app hostname]/`, controller
registered as `helloController` in dependency container will handles it.

```
router := container.get('router') as IRouter;
```
code above will return valid router instance because `THelloApp` inherits from `TSimpleWebApplication` which already register router instance automatically.
See [TSimpleWebApplication source code](https://github.com/fanoframework/fano/blob/master/src/App/Implementations/Cgi/SimpleCgi/SimpleAppImpl.pas).

## Build dispatcher instance

Fill `initDispatcher()` method body as follows

```
function THelloApp.initDispatcher(const container : IDependencyContainer) : IDispatcher;
begin
    result := container.get('dispatcher') as IDispatcher;
end;
```

`TSimpleWebApplication` class has registered a dispatcher instance in dependency container, so above code should suffice.

## Create hello controller

Create a file `hello-world/src/App/Hello/Controllers/HelloController.pas`

```
unit HelloController;

interface

uses

    fano;

type

    THelloController = class(TController)
    public
        function handleRequest(
            const request : IRequest;
            const response : IResponse
        ) : IResponse; override;
    end;

implementation

    function THelloController.handleRequest(
          const request : IRequest;
          const response : IResponse
    ) : IResponse;
    var greetName : string;
    begin
        greetName := request.getQueryParam('name', 'everybody');
        viewParams.setVar('name', greetName);
        result := inherited handleRequest(request, response);
    end;

end.

```
It reads query string `name` value and pass them to view parameters which will
get displayed in view

## Create hello controller factory class

Create new file `hello-world/src/App/Hello/Controllers/Factories/HelloControllerFactory.pas`

And fill its content as follows

```
unit HelloControllerFactory;

interface

uses
    fano;

type

    THelloControllerFactory = class(TFactory, IDependencyFactory)
    public
        function build(const container : IDependencyContainer) : IDependency; override;
    end;

implementation

uses
    sysutils,

    HelloController;

    function THelloControllerFactory.build(const container : IDependencyContainer) : IDependency;
    begin
        result := THelloController.create(
            container.get('routeMiddlewares') as IMiddlewareCollectionAware,
            container.get('helloView') as IView,
            container.get('viewParams') as IViewParameters
        );
    end;
end.
```

This factory builds `THelloController` and pass all dependencies to constructor
of the class.

## Create hello view

Create new file `hello-world/src/App/Hello/Views/HelloView.pas` with content as follows

```
unit HelloView;

interface

uses

    fano;

type

    THelloView = class(TInterfacedObject, IView)
    public
        function render(
            const viewParams : IViewParameters;
            const response : IResponse
        ) : IResponse;
    end;

implementation

    function THelloView.render(
        const viewParams : IViewParameters;
        const response : IResponse
    ) : IResponse;
    var respBody : IResponseStream;
        greet : string;
    begin
        greet := 'Hello' + viewParams.getVar('name');
        respBody := response.body();
        respBody.write('<html><head><title>' + greet + '</title></head>');
        respBody.write('<body><p>' + greet + '</p></body></html>');
        result := response;
    end;
end.
```

It read passed data from controller and build HTML of response.

## Create hello view factory class

Create new file `hello-world/src/App/Hello/Views/Factories/HelloViewFactories.pas` with content as follows

```
unit HelloViewFactory;

interface

uses
    fano;

type

    THelloViewFactory = class(TFactory)
    public
        function build(const container : IDependencyContainer) : IDependency; override;
    end;

implementation

uses

    SysUtils,
    HelloView;

    function THelloViewFactory.build(const container : IDependencyContainer) : IDependency;
    begin
        result := THelloView.create();
    end;
end.

```

## Register controller and view to dependency container

Edit `hello-world/src/helloapp.pas` to become

```
procedure THelloApp.buildDependencies(const container : IDependencyContainer);
begin
    container.factory(
        'routeMiddlewares',
        TNullMiddlewareCollectionAwareFactory.create()
    );
    container.add('viewParams', TViewParametersFactory.create());
    container.add('helloController', THelloControllerFactory.create());
    container.add('helloView', THelloViewFactory.create());
end;
```

Also add `HelloViewFactory.pas` and `HelloControllerFActory.pas` unit to `uses` clause of `helloapp.pas` unit.

```
uses

    SysUtils,
    HelloControllerFactory,
    HelloViewFactory;
```

## Final hello application unit

This is final content of our `helloapp.pas` unit

```
unit helloapp;

interface

uses
    fano;

type

    THelloApp = class(TSimpleWebApplication)
    protected
        procedure buildDependencies(const container : IDependencyContainer); override;
        procedure buildRoutes(const container : IDependencyContainer); override;
        function initDispatcher(const container : IDependencyContainer) : IDispatcher; override;
    end;

implementation

uses

    sysutils,
    HelloControllerFactory,
    HelloViewFactory;

    procedure THelloApp.buildDependencies(const container : IDependencyContainer);
    begin
        container.factory(
            'routeMiddlewares',
            TNullMiddlewareCollectionAwareFactory.create()
        );
        container.add('viewParams', TViewParametersFactory.create());
        container.add('helloController', THelloControllerFactory.create());
        container.add('helloView', THelloViewFactory.create());
    end;

    procedure THelloApp.buildRoutes(const container : IDependencyContainer);
    var router : IRouter;
    begin
        router := container.get('router') as IRouter;
        try
            router.get('/', container.get('helloController') as IRouteHandler);
        finally
            router := nil;
        end;
    end;

    function THelloApp.initDispatcher(const container : IDependencyContainer) : IDispatcher;
    begin
        result := container.get('dispatcher') as IDispatcher;
    end;
end.
```

## Creating build script

This is an optional task, but helps simplify task to compile and build application.

Create new file `hello-world/build.sh`

```
#!/bin/bash

if [[ -z "${FANO_DIR}" ]]; then
export FANO_DIR="vendor/fano"
fi

if [[ -z "${BUILD_TYPE}" ]]; then
export BUILD_TYPE="prod"
fi

if [[ -z "${USER_APP_DIR}" ]]; then
export USER_APP_DIR="app"
fi

if [[ -z "${UNIT_OUTPUT_DIR}" ]]; then
    export UNIT_OUTPUT_DIR="bin/unit"
fi

if [[ -z "${EXEC_OUTPUT_DIR}" ]]; then
export EXEC_OUTPUT_DIR="public"
fi

if [[ -z "${EXEC_OUTPUT_NAME}" ]]; then
export EXEC_OUTPUT_NAME="app.cgi"
fi

if [[ -z "${SOURCE_PROGRAM_NAME}" ]]; then
export SOURCE_PROGRAM_NAME="app.pas"
fi

if [[ -z "${FPC_BIN}" ]]; then
export FPC_BIN="fpc"
fi

${FPC_BIN} @fano/fano.cfg @build.cfg ${USER_APP_DIR}/${SOURCE_PROGRAM_NAME}

```

Change add execute permission to `build.sh`

```
$ chmod +x build.sh
```

## Explore more

- [Step by Step Tutorials](/tutorials)
